package abarson.transloc.validation;

import java.util.List;
import java.util.Map;

import abarson.transloc.api.Route;
import abarson.transloc.api.Stop;
import abarson.transloc.exception.RouteException;
import abarson.transloc.exception.StopException;

/**
 * Performs validation logic for provided {@link Route} and {@link Stop} information. 
 * 
 * <p>
 * 
 * The responsibility of {@code Validator} is to ensure that given a {@code Route}/{@code Stop}, 
 * they are both active (in season), and are compatible (a given {@code Route} stops at a given {@code Stop}).
 * The {@link RouteCorrector} and {@link StopCorrector} classes are responsible for ensuring that user provided
 * {@code Route} names and {@code Stop} names actually exist.
 * @author adambarson
 *
 */
public final class Validator {
	
	private Validator(){}
	
	/**
	 * Checks for compatibility between a {@code Route} and {@code Stop}. This method is used when the user
	 * provides both a route name and stop name to be validated. The {@code Stop} is validated first, 
	 * and then the {@code Route} is validated using the provided {@code Stop} as an extra consideration.
	 * If the {@code Route} both exists in the Transloc API {@code Route} list, and contains the provided stop
	 * in its stop list, then this method returns the validated {@code Stop}.
	 * @param routeList
	 * 			The {@code Route} list retrieved from Transloc API
	 * @param routeName
	 *			The provided name of a {@code Route} to be validated
	 * @param stop
	 * 			The {@code Stop} to be used in validating the {@code Route}
	 * @return The validated {@code Route}
	 * @throws RouteException
	 */
	public static Route validateRouteAndStop(List<Route> routeList, String routeName, Stop stop, Map<String, Boolean> activeRoutes) throws RouteException{
		Route route = fetchRoute(routeList, routeName);
		if (!activeRoutes.get(route.getLong_name().toUpperCase())){
			throw new RouteException("The " + routeName + " is not currently active.");
		}
		if (!checkRouteContainsStop(route, stop)){
			throw new RouteException("The " + routeName + " doesn't stop at " + stop.getName());
		}
		return route;
	}
	
	/**
	 * Checks to see if the provided stop name is contained by the Transloc API stopList, 
	 * and whether or not there are any shuttles stopping there. If the stop name is valid,
	 * returns the associated {@code Stop} object. Otherwise, throws a {@link StopException}
	 * @param stopList
	 * 			The {@code Stop} list returned by the Transloc API
	 * @param stopName
	 * 			The name of a {@code Stop} provided by the user
	 * @return A validated {@code Stop} object that corresponds to the provided stopName
	 */
	public static Stop validateStop(List<Stop> stopList, String stopName) throws StopException{
		for (Stop s : stopList){
			if (s.getName().equals(stopName)){
				if (s.getRoutes().length > 0){ //if there are no buses coming to this stop, do not return it.
					return s;
				} else {
					throw new StopException("There are no shuttles coming to " + stopName + ".");
				}
			}
		}
		throw new StopException("The " + stopName + " stop is currently out of season.");
	}
	
	
	/**
	 * Helper method that checks to confirm that a {@code Route} stop list contains the stopId of a {@code Stop},
	 * i.e., checks that the given route actually stops at the provided stop.
	 * 
	 * @param route 
	 * 			The {@code Route} to check
	 * @param stop 
	 * 			The {@code Stop} to check
	 * @return {@code true} if the {@code Route} visits the {@code Stop} represented by stopId
	 */
	private static boolean checkRouteContainsStop(Route route, Stop stop){
		for (int i = 0; i < route.getStops().length; ++i){
			if (route.getStops()[i].equals(stop.getStop_id())){
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Given a {@code Route} list generated by a call to the Transloc API, and a routeName provided by the user,
	 * return the {@code Route} associated with that routeName, or throw a {@link RouteException} if no
	 * such {@code Route} is found.
	 * @param routeList 
	 * 			The {@code Route} list returned by the Transloc API
	 * @param routeName 
	 * 			The name of a {@code Route} provided by the user
	 * @return A the validated {@code Route} object that corresponds to the provided routeName
	 * @throws RouteException
	 */
	public static Route fetchRoute(List<Route> routeList, String routeName) throws RouteException{
		for (Route r : routeList){
			if (r.getLong_name().equals(routeName)){
				return r;
			}
		}
		throw new RouteException("The " + routeName + " shuttle doesn't run this time of year.");
	}
	
	
}
